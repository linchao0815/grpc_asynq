// Code generated by protoc-gen-go-asynqgen. DO NOT EDIT.
// versions:
// protoc-gen-go-asynqgen v1.0.10

package v1

import (
	context "context"
	json "encoding/json"
	asynq "github.com/hibiken/asynq"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

import (
	"fmt"
	"net/http"
	"myasynq"
	"strings"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/attribute"
	rkgrpcctx "github.com/rookie-ninja/rk-grpc/v2/middleware/context"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the asynq package it is being compiled against.
var _ = new(context.Context)
var _ = new(asynq.Task)
var _ = new(emptypb.Empty)
var _ = new(proto.Message)
var _ = new(json.InvalidUTF8Error)

type ServerB_TaskJobServer interface {
	CallB_Task(context.Context, *CallB_TaskReq) error
}

func RegisterServerB_TaskJobServer(mux *asynq.ServeMux, srv ServerB_TaskJobServer) {
	mux.HandleFunc("ServerA_Task:CallB_Task", _ServerB_Task_CallB_Task_Job_Handler(srv))
}

func _ServerB_Task_CallB_Task_Job_Handler(srv ServerB_TaskJobServer) func(context.Context, *asynq.Task) error {
	return func(ctx context.Context, task *asynq.Task) error {
		var in CallB_TaskReq
		t := &myasynq.TaskPaylod{In: &in}
		if err := json.Unmarshal(task.Payload(), &t); err != nil {
			return fmt.Errorf("%s req=%s err=%s", task.Type(), t, err)
		}
		ctx, span := myasynq.NewSpan(ctx, "CallB_Task")
		err := srv.CallB_Task(ctx, t.In.(*CallB_TaskReq))
		span.SetAttributes(attribute.String("req", myasynq.ToMarshal(t)))
		myasynq.EndSpan(span, err == nil)
		return err
	}
}

type ServerB_TaskSvcJob struct{}

var ServerB_TaskJob ServerB_TaskSvcJob

func (j *ServerB_TaskSvcJob) CallB_Task(ctx context.Context, in *CallB_TaskReq, opts ...asynq.Option) (*asynq.Task, *http.Header, error) {
	// get trace metadata
	header := http.Header{}
	rkgrpcctx.GetTracerPropagator(ctx).Inject(ctx, propagation.HeaderCarrier(header))
	payload, err := json.Marshal(myasynq.TaskPaylod{
		In:          in,
		TraceHeader: header,
	})
	if err != nil {
		return nil, nil, err
	}

	task := asynq.NewTask("ServerA_Task:CallB_Task", payload, opts...)
	return task, &header, nil
}

type ServerB_TaskJobClient interface {
	CallB_Task(ctx context.Context, req *CallB_TaskReq, opts ...asynq.Option) (info *asynq.TaskInfo, err error)
}

type ServerB_TaskJobClientImpl struct {
	cc *asynq.Client
}

func NewServerB_TaskJobClient(client *asynq.Client) ServerB_TaskJobClient {
	return &ServerB_TaskJobClientImpl{client}
}

func (c *ServerB_TaskJobClientImpl) CallB_Task(ctx context.Context, in *CallB_TaskReq, opts ...asynq.Option) (*asynq.TaskInfo, error) {
	task, header, err := ServerB_TaskJob.CallB_Task(ctx, in, opts...)
	if err != nil {
		return nil, fmt.Errorf("ServerA_TaskJob.GameTest_Task req:%s err:%s", in, err)
	}
	info, err := c.cc.Enqueue(task)
	if err != nil {
		return nil, fmt.Errorf("ServerA_TaskJob.GameTest_Task Enqueue req:%s err:%s", in, err)
	}
	// 把 Trace 信息，存入 Metadata，以 Header 的形式返回给 httpclient
	for k, v := range *header {
		rkgrpcctx.AddHeaderToClient(ctx, k, strings.Join(v, ","))
	}
	return info, nil
}
